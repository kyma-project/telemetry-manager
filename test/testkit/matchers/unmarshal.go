package matchers

import (
	"bufio"
	"bytes"
	"fmt"
	"io"

	"go.opentelemetry.io/collector/pdata/plog"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/pdata/ptrace"
)

// UnmarshalOTLPJSONData unmarshals OTLP signal data from a JSONL-encoded file data (every line is a JSON document encoding OTLP data - plog.Logs, pmetric.Metrics, or ptrace.Traces).
// The file is generated by the fileexporter in a mock backend in the test suite.
func UnmarshalOTLPJSONData[T plog.Logs | pmetric.Metrics | ptrace.Traces](jsonData []byte, unmarshalFunc func(buf []byte) (T, error)) ([]T, error) {
	var otlpData []T

	// User bufio.Reader instead of bufio.Scanner to handle very long lines gracefully
	reader := bufio.NewReader(bytes.NewReader(jsonData))

	for {
		lineJSONData, readerErr := reader.ReadBytes('\n')
		if readerErr != nil && readerErr != io.EOF {
			return nil, fmt.Errorf("failed to read line: %w", readerErr)
		}

		if len(lineJSONData) > 0 {
			lineOTLPData, unmarshalErr := unmarshalFunc(lineJSONData)
			if unmarshalErr != nil {
				if lastLine := readerErr == io.EOF; lastLine {
					// If the error is due to the last line not being complete, we can still return the data read so far
					// but we should not return an error.
					break
				}

				return nil, fmt.Errorf("failed to unmarshal data: total bytes: %d, line bytes: %d, error: %w", len(jsonData), len(lineJSONData), unmarshalErr)
			}

			otlpData = append(otlpData, lineOTLPData)
		}

		// check the io.EOF error after checking the line since both can be returned simultaneously
		if readerErr == io.EOF {
			break
		}
	}

	return otlpData, nil
}
